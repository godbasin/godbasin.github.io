---
title: 前端知识库--1.掌握浏览器的加载和渲染流程
date: 2020-12-19 08:48:23
categories: 前端知识库
tags: 基础进阶
---

最近在整理一些之前写的比较散的内容，希望可以将一些自己的理解整合成比较有结构和逻辑的内容分享给到大家。本文主要浏览器的页面渲染过程~

<!--more-->

作为前端开发，我们的日常工作中除了编码以外，几乎大多数时间都在跟浏览器打交道。因此，我们应该对浏览器的了解要更加深入，掌握它是怎样将我们编写的代码渲染到页面中的。

## 认识浏览器

如今我们在主要使用的浏览器包括：

- 台式机：Chrome、Internet Explorer、Firefox、Safari、Opera 等
- 移动设备：Android 浏览器、iPhone、Opera Mini、Opera Mobile、UC 浏览器、Chrome 等。

上面提到的这些浏览器，除 Opera 以外都是基于 WebKit 内核。

### 浏览器主要功能

浏览器的主要功能，是通过向服务器请求并在浏览器窗口中展示这些资源内容，这些内容通常包括 HTML 文档、PDF、图像等，我们也可以通过插件的方式加载更多其他的资源类型。

一般来说，我们在浏览器中会用到以下功能：

- 用于输入 URI 的地址栏
- 刷新和停止按钮，来控制当前文档的加载
- 后退和前进按钮，控制文档历史的快速访问
- 书签和收藏选项

HTML 和 CSS 规范中规定了浏览器解析和渲染 HTML 文档的方式，曾经各个浏览器都只遵循其中一部分，因此前端开发经常需要兼容各种浏览器。现在这些问题已经得到改善，同时配合 Babel 等一些兼容性处理编译过程，我们可以更加关注网站的功能实现和优化。

### 浏览器的结构

![](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-1.jpg)

如图，从结构上来说，浏览器主要包括了八个子系统：

- **用户界面**：包括前面提到的用户主要功能地址栏，状态栏和工具栏等
- **浏览器引擎**：一个可嵌入的组件，它提供了用于查询和操作渲染引擎的高级界面
- **渲染引擎**：负责显示请求的内容，比如用于对 HTML 文档进行解析和布局，可以选择使用 CSS 样式化
- **网络子系统**：用于 HTTP 请求之类的网络调用，在独立于平台的界面后面针对不同平台使用不同的实现
- **JavaScript 解释器**：用于解析和执行 JavaScript 代码
- **XML 解析器**：用于解析和运行 XML 代码
- **显示后端**：用于绘制基本小部件和字体，例如组合框和窗口
- **数据持久性子系统**：即数据存储，该子系统在磁盘上存储与浏览会话相关的各种数据，包括书签，Cookie 和缓存

这些子系统组合构成了我们的浏览器，而谈到页面的加载和渲染，则离不开网络子系统、渲染引擎、JavaScript 解释器和浏览器引擎等。下面我们以前端开发最常使用的 Chrome 浏览器为例，进行更详细的介绍。

> Chrome 浏览器相关的内容主要参考[Inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part1)一文，文章写得特别详细和形象，强烈推荐大家进行阅读。

#### Chrome 多进程架构

关于进程和线程的概念，这里不多介绍，这些也都是开发需要掌握的基础内容，大家可以自行进行学习。

Chrome 使用了多进程架构，具有以下进程：

![](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-1.png)

| 进程       | 描述                                                                                                             |
| ---------- | ---------------------------------------------------------------------------------------------------------------- |
| 浏览器进程 | 控制和处理用户可见的 UI 部分（包括地址栏，书签，后退和前进按钮）和用户不可见的隐藏部分（例如网络请求和文件访问） |
| 渲染器进程 | 控制显示网站的选项卡中的内容                                                                                     |
| 插件进程   | 控制网站使用的插件（例如 Flash）                                                                                 |
| GPU 进程   | 与其他进程隔离地处理 GPU 任务                                                                                    |

Chrome 等浏览器支持多个选项卡，每个选项卡在单独的渲染器进程中运行。如果一个选项卡变得无响应，则可以关闭无响应的选项卡并继续运行，同时保持其他选项卡的活动状态。

#### Chrome 浏览器进程

除了每个选项卡在单独的渲染器进程中运行，选项卡之外的所有内容都由浏览器进程处理。

其中，浏览器进程具有以下线程：

- **UI 线程**：用于绘制浏览器的按钮和输入字段
- **网络线程**：用于处理网络请求，以及从服务器接收数据
- **存储线程**：用于控制对文件的访问
- **GUI 渲染线程**：负责对浏览器界面进行渲染
- **JavaScript 引擎线程**：负责解析和执行 JavaScript 脚本
- **浏览器定时器触发线程**：`setTimeout`和`setInterval`所在的线程
- **浏览器事件触发线程**：该线程负责处理浏览器事件，并将事件触发后需要执行的代码放置到 JavaScript 引擎中执行

这些线程在我们的基本认知和日常开发中多少有些了解，包括：

- 页面的加载过程，涉及 GUI 渲染线程与 JavaScript 引擎线程间的互斥关系
- Event Loop 中对事件的处理，涉及浏览器事件触发线程、浏览器事件触发线程、非阻塞设计的 JavaScript 引擎线程
- 网络请求，涉及网络线程的处理过程（包括 DNS 解析、TCP 建连、HTTP 建立等等）

下面我们来介绍浏览器中页面加载和渲染过程。

## 浏览器中页面的加载和渲染

这里我们将基于 Chrome 浏览器，更加详细地介绍浏览器进程和线程如何通信来显示页面，主要分为两部分：

- 页面导航：用户输入 URL，浏览器进程进行请求和准备处理
- 页面渲染：获取到相关资源后，渲染器进程负责选项卡内部的渲染处理

### 页面导航

在地址栏中输入内容时，浏览器会进行：

1. 首先由浏览器进程的 UI 线程进行处理。如果是 URI，UI 线程会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。
2. 请求过程由网络线程来完成（下面会简单描述一个 HTTP 请求过程）。如果响应是 HTML 文件，则是将数据传递到渲染器进程；如果是其他文件，则意味着这是下载请求，此时会将数据传递到下载管理器。
3. 确认浏览器应导航到请求站点后，网络线程通知 UI 线程数据准备就绪。
4. UI 线程寻找一个渲染器进程来进行网页渲染，数据和渲染器进程都准备好后，HTML 数据通过 IPC 从浏览器进程传递到渲染器进程中。
5. 渲染器进程接收 HTML 数据后，将开始加载资源并渲染页面。
6. 渲染器进程完成渲染后，通过 IPC 通知浏览器进程页面已加载。

> 其中，一个 HTTP 请求过程如下：
>
> 1. DNS 域名解析（此处涉及 DNS 的寻址过程），找到网页的存放服务器。
> 2. 浏览器与服务器建立 TCP 连接。
> 3. 浏览器发起 HTTP 请求。
> 4. 服务器响应 HTTP 请求，返回对应的资源内容。

以上是用户在地址栏输入网站地址，到页面开始渲染的整体过程。如果当前页面跳转到其他网站，浏览器将调用一个单独的渲染进程来处理新导航，同时保留当前渲染进程来处理像`unload`这类事件。

### 页面加载

浏览器在加载页面的时候会用到 GUI 渲染线程和 Javascript 引擎线程。GUI 渲染线程负责渲染浏览器界面 HTML 元素，Javascript 引擎线程主要负责处理 Javascript 脚本程序，它们之间是互斥的关系，当 Javascript 引擎执行时 GUI 线程会被挂起。

因此，正常的网页渲染流程是这样的：

1. 浏览器一边下载 HTML 网页，一边开始解析。
2. 解析过程中，发现`<script>`标签。
3. 暂停解析，网页渲染的控制权转交给 Javascript 引擎线程。
4. 如果`<script>`标签引用了外部脚本，就下载该脚本，否则就直接执行。
5. 执行完毕，控制权交还渲染器进程，恢复往下解析`HTML`网页。

浏览器需要在解析到`<body>`标签的时候才开始渲染页面，因此把 Javascript 放在`<head>`里，意味着必须把所有 Javascript 代码都下载、解析和解释完成后，才能开始渲染页面。

如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕。因此，我们常常将 Javascript 放在`<body>`的最后面，可以避免资源阻塞，页面得以迅速展示。当然，我们还可以使用`document.write()`API，或者是`defer`/`async`/`preload`等属性来标记`<script>`标签，来控制 Javascript 的加载顺序。

除此之外，浏览器在渲染页面的过程需要解析 HTML、CSS 得到 DOM 树和 CSS 规则树，它们结合才生成最终的渲染树并渲染。因此，我们还常常将 CSS 放在`<head>`里，可用来避免浏览器渲染的重复计算。

下面我们来介绍页面渲染过程。

### 页面渲染

渲染器进程负责选项卡内部发生的所有事情，它的核心工作是将 HTML、CSS 和 JavaScript 转换为可交互的页面，因此会解析以下内容：

- 渲染引擎解析 HTML/SVG/XHTML 文件，解析这三种文件会产生一个 DOM 节点树
- 渲染引擎解析 CSS，会产生 CSS 规则树
- JavaScript 解释器解析 Javascript 脚本，Javascript 脚本可以通过 DOM API 和 CSSOM API 来操作 DOM 节点树和 CSS 规则树

解析完成后，浏览器引擎会通过 DOM 节点树和 CSS 规则树来构造渲染树（Render Tree）。在这个过程中，像`header`或`display:none`的元素，它们会存在 DOM 节点树中，但不会被添加到渲染树里。大致流程如下图：

![浏览器构造渲染树流程](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/flow.png)

渲染的流程基本上如下：

1. **解析(Parser)**：构建渲染树。
2. **布局(Layout)**：定位坐标和大小、是否换行、各种`position`/`overflow`/`z-index`属性等计算。
3. **绘制(Paint)**：判断元素渲染层级顺序。
4. **光栅化(Raster)**：将计算后的信息转换为屏幕上的像素。

合成器和光栅线程也运行在渲染器进程内部，来高效、流畅地渲染页面。

#### 页面布局

渲染的过程中会触发重绘（Repaint）和重排（Reflow）：

- 重绘：屏幕的一部分要重画，比如某个 CSS 的背景色变了，但是元素的几何尺寸没有变
- 重排：元素的几何尺寸变了（渲染树的一部分或全部发生了变化），需要重新验证并计算渲染树

为了不对每个小的变化都进行完整的布局计算，渲染器会将更改的元素和它的子元素进行脏位标记，表示该元素需要重新布局。其中，全局样式更改会触发全局布局，部分样式或元素更改会触发增量布局，增量布局是异步完成的，全局布局则会同步触发。

重排需要涉及变更的所有的结点几何尺寸和位置，成本比重绘的成本高得多的多。所以我们要注意以避免频繁地进行增加、删除、修改 DOM 结点、移动 DOM 的位置、Resize 窗口、滚动等操作，因为可能会导致性能降低。

如果要设置动画元素，浏览器必须在每帧之间运行这些操作。我们的大多数显示器每秒刷新屏幕 60 次（`60 fps`）。当我们在每一帧中在屏幕上移动物体时，动画将对人眼显得平滑。但是，如果动画错过了它们之间的帧，则页面会变得卡顿不连续。

由于 GUI 渲染线程和 Javascript 引擎线程是互斥的，当我们的网页在运行 JavaScript 时，渲染操作可能会被阻止，动画则无法流畅运行。因此，我们可以将 JavaScript 操作分成小块，并计划使用在每个帧上运行`requestAnimationFrame()`。

#### 光栅化

通过解析、计算和布局过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。将这些信息转换为屏幕上的像素，这个过程被称为光栅化。

光栅化可以被 GPU 加速，光栅化后的位图会被存储在 GPU 内存中。根据前面介绍的渲染流程，当页面布局变更了会触发重排和重绘，还需要重新进行光栅化。此时如果页面中有动画，则主线程中过多的计算任务很可能会影响动画的性能。

因此，现代的浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片），并通过合成器线程进行页面的合成。

![](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-2.jpg)

过程如下：

1. 当主线程创建了合成层并确定了绘制顺序，便将这些信息提交给合成线程。
2. 合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程。
3. 光栅线程栅格化每个瓦片，并将它们存储在 GPU 内存中。
4. 合成器线程通过 IPC 提交给浏览器进程，这些合成器帧被发送到 GPU 进程处理，并显示在屏幕上。

![](https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/how-browser-works-2.png)

合成的真正目的是，在移动合成层的时候不用重新光栅化。因为有了合成器线程，页面才可以独立于主线程进行流畅的滚动。

到此，我们的页面便渲染完成。

### 事件处理

当用户与浏览器进行交互时，浏览器进程将首先接收事件。

但是，浏览器进程只知道该事件发生在哪里，因为选项卡内部的内容由渲染器进程处理。因此，浏览器进程将事件类型（如`click`）及其坐标发送给渲染器进程。渲染器进程通过找到事件目标并运行附加的事件侦听器来适当地处理事件。

基于前面我们提到浏览器有合成层，那么如果将某些事件侦听器添加到页面上怎么办？合成器线程怎么知道某个事件是否需要处理呢：

1. 在合成页面时，合成器线程会将页面上具有事件处理程序的区域标记为“非快速可滚动区域”。
2. 如果事件发生在该区域中，则合成器线程可以确保将输入事件发送到主线程。
3. 如果输入事件来自该区域之外，则合成器线程将在不等待主线程的情况下进行新帧的合成。

这会带来什么问题呢？由于事件冒泡的机制，我们常常会使用事件委托的方式，在父类元素添加事件侦听器。有时候为了方便，我们会直接在`document.body`上进行事件委托。

在这种情况下，整个页面都被标记为不可快速滚动的区域。这意味着，即使我们的页面不关心某些部分的用户交互，合成器线程也必须与主线程进行通信，并在每次事件发生时进行等待。

在这种情况下，我们可以使用`passive: true`选项：这表示我们仍要在主线程中侦听事件，但是合成器也可以继续合成新的框架。

以上，我们基于 Chrome 浏览器进行了详细的浏览器页面渲染的过程，如果想要了解各个浏览器内核之间的渲染差异，可以查看[How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)这篇文章。

### 参考

- [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
- [Inside look at modern web browser](https://developers.google.com/web/updates/2018/09/inside-browser-part1)

## 总结

最近文章写得不那么频繁，一年总有那么几个月就是酱紫的啦~
有时候也要给自己一点空间和时间，允许自己有些事情没做好、有些结果不如预期，不要过于在意一两次、一两年的成果呢~
